{
    "name": "python_advanced",
    "language": "python",
    "category": "advanced",
    "description": "Advanced Python script with comprehensive error handling, configuration, and logging",
    "content": "#!/usr/bin/env python3\n\"\"\"\n{{description}}\nGenerated by ScripGen\n{{alsaniaSignature}}\n\"\"\"\n\nimport sys\nimport os\nimport logging\nimport argparse\nimport json\nimport pathlib\nfrom typing import Dict, List, Optional, Any\nfrom dataclasses import dataclass, asdict\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.StreamHandler(sys.stdout),\n        logging.FileHandler('/tmp/{{scriptName}}.log', mode='a')\n    ]\n)\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Config:\n    \"\"\"Configuration class for the script\"\"\"\n    log_level: str = \"INFO\"\n    dry_run: bool = False\n    config_file: Optional[str] = None\n    output_dir: str = \"./output\"\n    \n    def __post_init__(self):\n        if self.config_file is None:\n            home = pathlib.Path.home()\n            self.config_file = str(home / \".config\" / \"{{scriptName}}\" / \"config.json\")\n\nclass ScriptError(Exception):\n    \"\"\"Custom exception for script errors\"\"\"\n    pass\n\nclass ConfigurationManager:\n    \"\"\"Manages script configuration\"\"\"\n    \n    def __init__(self, config_file: str):\n        self.config_file = pathlib.Path(config_file)\n        self.config = Config()\n    \n    def load(self) -> Config:\n        \"\"\"Load configuration from file\"\"\"\n        try:\n            if self.config_file.exists():\n                with open(self.config_file, 'r') as f:\n                    data = json.load(f)\n                    self.config = Config(**data)\n                logger.info(f\"Configuration loaded from {self.config_file}\")\n            else:\n                logger.info(\"No configuration file found, using defaults\")\n        except Exception as e:\n            logger.warning(f\"Failed to load configuration: {e}\")\n        return self.config\n    \n    def save(self) -> None:\n        \"\"\"Save configuration to file\"\"\"\n        try:\n            self.config_file.parent.mkdir(parents=True, exist_ok=True)\n            with open(self.config_file, 'w') as f:\n                json.dump(asdict(self.config), f, indent=2)\n            logger.info(f\"Configuration saved to {self.config_file}\")\n        except Exception as e:\n            logger.error(f\"Failed to save configuration: {e}\")\n\nclass DependencyValidator:\n    \"\"\"Validates required dependencies\"\"\"\n    \n    def __init__(self, required_modules: List[str]):\n        self.required_modules = required_modules\n    \n    def validate(self) -> bool:\n        \"\"\"Validate all required dependencies\"\"\"\n        missing = []\n        for module in self.required_modules:\n            try:\n                __import__(module)\n            except ImportError:\n                missing.append(module)\n        \n        if missing:\n            logger.error(f\"Missing required modules: {', '.join(missing)}\")\n            return False\n        \n        logger.info(\"All dependencies validated successfully\")\n        return True\n\nclass FileValidator:\n    \"\"\"Validates file and directory operations\"\"\"\n    \n    @staticmethod\n    def validate_file_exists(file_path: str) -> bool:\n        \"\"\"Validate that a file exists and is readable\"\"\"\n        path = pathlib.Path(file_path)\n        if not path.exists():\n            logger.error(f\"File not found: {file_path}\")\n            return False\n        if not path.is_file():\n            logger.error(f\"Path is not a file: {file_path}\")\n            return False\n        return True\n    \n    @staticmethod\n    def validate_directory_exists(dir_path: str, create_if_missing: bool = False) -> bool:\n        \"\"\"Validate that a directory exists and is writable\"\"\"\n        path = pathlib.Path(dir_path)\n        if not path.exists():\n            if create_if_missing:\n                try:\n                    path.mkdir(parents=True, exist_ok=True)\n                    logger.info(f\"Created directory: {dir_path}\")\n                    return True\n                except Exception as e:\n                    logger.error(f\"Failed to create directory {dir_path}: {e}\")\n                    return False\n            else:\n                logger.error(f\"Directory not found: {dir_path}\")\n                return False\n        if not path.is_dir():\n            logger.error(f\"Path is not a directory: {dir_path}\")\n            return False\n        return True\n\ndef parse_arguments() -> argparse.Namespace:\n    \"\"\"Parse command line arguments\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"{{description}}\",\n        formatter_class=argparse.RawDescriptionHelpFormatter\n    )\n    \n    parser.add_argument(\n        '-c', '--config',\n        type=str,\n        help='Configuration file path'\n    )\n    \n    parser.add_argument(\n        '-v', '--verbose',\n        action='store_true',\n        help='Enable verbose logging'\n    )\n    \n    parser.add_argument(\n        '--dry-run',\n        action='store_true',\n        help='Show what would be done without executing'\n    )\n    \n    parser.add_argument(\n        '--output-dir',\n        type=str,\n        help='Output directory'\n    )\n    \n    return parser.parse_args()\n\ndef setup_logging(verbose: bool = False) -> None:\n    \"\"\"Setup logging configuration\"\"\"\n    level = logging.DEBUG if verbose else logging.INFO\n    logging.getLogger().setLevel(level)\n    logger.info(f\"Logging level set to {logging.getLevelName(level)}\")\n\ndef main():\n    \"\"\"Main script execution\"\"\"\n    start_time = datetime.now()\n    logger.info(\"Starting script execution...\")\n    \n    try:\n        # Parse arguments\n        args = parse_arguments()\n        \n        # Setup logging\n        setup_logging(args.verbose)\n        \n        # Load configuration\n        config_file = args.config or os.getenv('CONFIG_FILE')\n        config_manager = ConfigurationManager(config_file)\n        config = config_manager.load()\n        \n        # Override config with command line arguments\n        if args.dry_run:\n            config.dry_run = True\n        if args.output_dir:\n            config.output_dir = args.output_dir\n        \n        # Validate dependencies\n        validator = DependencyValidator({{dependencies}})\n        if not validator.validate():\n            raise ScriptError(\"Dependency validation failed\")\n        \n        # Validate output directory\n        if not FileValidator.validate_directory_exists(config.output_dir, create_if_missing=True):\n            raise ScriptError(\"Output directory validation failed\")\n        \n        # Execute main logic\n        {{mainLogic}}\n        \n        # Save configuration\n        config_manager.save()\n        \n        execution_time = datetime.now() - start_time\n        logger.info(f\"Script completed successfully in {execution_time}\")\n        \n    except KeyboardInterrupt:\n        logger.info(\"Script interrupted by user\")\n        sys.exit(1)\n    except ScriptError as e:\n        logger.error(f\"Script error: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\", exc_info=True)\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()",
    "variables": [
        {
            "name": "description",
            "type": "string",
            "required": true,
            "description": "Script description"
        },
        {
            "name": "scriptName",
            "type": "string",
            "required": true,
            "description": "Script name for configuration"
        },
        {
            "name": "dependencies",
            "type": "array",
            "required": false,
            "description": "Required Python modules"
        },
        {
            "name": "mainLogic",
            "type": "string",
            "required": true,
            "description": "Main script logic"
        }
    ],
    "requirements": [
        "python3"
    ],
    "alsaniaCompliant": true
}