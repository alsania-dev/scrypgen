{
    "name": "python_complex",
    "language": "python",
    "category": "complex",
    "description": "Complex Python application with modular architecture, configuration management, and advanced features",
    "content": "#!/usr/bin/env python3\n\"\"\"\n{{description}}\nGenerated by ScripGen\n{{alsaniaSignature}}\n\"\"\"\n\nimport sys\nimport os\nimport logging\nimport argparse\nimport json\nimport pathlib\nimport asyncio\nimport signal\nimport threading\nfrom typing import Dict, List, Optional, Any, Callable\nfrom dataclasses import dataclass, field, asdict\nfrom datetime import datetime, timedelta\nfrom abc import ABC, abstractmethod\nimport inspect\n\n# =============================================================================\n# CONFIGURATION MANAGEMENT\n# =============================================================================\n\n@dataclass\nclass ApplicationConfig:\n    \"\"\"Main application configuration\"\"\"\n    name: str = \"{{scriptName}}\"\n    version: str = \"1.0.0\"\n    log_level: str = \"INFO\"\n    log_file: Optional[str] = None\n    config_file: Optional[str] = None\n    dry_run: bool = False\n    debug: bool = False\n    \n    # Feature flags\n    enable_async: bool = True\n    enable_threading: bool = False\n    enable_metrics: bool = True\n    \n    # Paths\n    data_dir: str = \"./data\"\n    output_dir: str = \"./output\"\n    temp_dir: str = \"./temp\"\n    \n    def __post_init__(self):\n        if self.config_file is None:\n            home = pathlib.Path.home()\n            self.config_file = str(home / \".config\" / self.name / \"config.json\")\n        if self.log_file is None:\n            self.log_file = f\"/tmp/{self.name}.log\"\n\n# =============================================================================\n# LOGGING SYSTEM\n# =============================================================================\n\nclass Logger:\n    \"\"\"Enhanced logging system\"\"\"\n    \n    def __init__(self, config: ApplicationConfig):\n        self.config = config\n        self._setup_logging()\n    \n    def _setup_logging(self):\n        \"\"\"Setup comprehensive logging\"\"\"\n        level = getattr(logging, self.config.log_level.upper(), logging.INFO)\n        \n        # Create formatters\n        file_formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'\n        )\n        console_formatter = logging.Formatter(\n            '%(asctime)s - %(levelname)s - %(message)s'\n        )\n        \n        # Setup handlers\n        handlers = [logging.StreamHandler(sys.stdout)]\n        \n        if self.config.log_file:\n            file_handler = logging.FileHandler(self.config.log_file)\n            file_handler.setFormatter(file_formatter)\n            handlers.append(file_handler)\n        \n        # Configure root logger\n        logging.basicConfig(\n            level=level,\n            handlers=handlers,\n            force=True\n        )\n        \n        self.logger = logging.getLogger(self.config.name)\n    \n    def get_logger(self, name: str = None) -> logging.Logger:\n        \"\"\"Get a logger instance\"\"\"\n        return logging.getLogger(f\"{self.config.name}.{name}\" if name else self.config.name)\n\n# =============================================================================\n# EXCEPTION HANDLING\n# =============================================================================\n\nclass ApplicationError(Exception):\n    \"\"\"Base application exception\"\"\"\n    pass\n\nclass ConfigurationError(ApplicationError):\n    \"\"\"Configuration related errors\"\"\"\n    pass\n\nclass ValidationError(ApplicationError):\n    \"\"\"Validation related errors\"\"\"\n    pass\n\nclass ExecutionError(ApplicationError):\n    \"\"\"Execution related errors\"\"\"\n    pass\n\n# =============================================================================\n# VALIDATION SYSTEM\n# =============================================================================\n\nclass Validator(ABC):\n    \"\"\"Abstract base class for validators\"\"\"\n    \n    @abstractmethod\n    def validate(self, data: Any) -> bool:\n        \"\"\"Validate the given data\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_errors(self) -> List[str]:\n        \"\"\"Get validation errors\"\"\"\n        pass\n\nclass DependencyValidator(Validator):\n    \"\"\"Validates required dependencies\"\"\"\n    \n    def __init__(self, required_modules: List[str]):\n        self.required_modules = required_modules\n        self.errors = []\n    \n    def validate(self, data: Any = None) -> bool:\n        \"\"\"Validate Python module dependencies\"\"\"\n        self.errors = []\n        for module in self.required_modules:\n            try:\n                __import__(module)\n            except ImportError:\n                self.errors.append(f\"Missing required module: {module}\")\n        return len(self.errors) == 0\n    \n    def get_errors(self) -> List[str]:\n        return self.errors\n\nclass FileSystemValidator(Validator):\n    \"\"\"Validates file system requirements\"\"\"\n    \n    def __init__(self, required_paths: Dict[str, str]):\n        self.required_paths = required_paths\n        self.errors = []\n    \n    def validate(self, data: Any = None) -> bool:\n        \"\"\"Validate file system paths\"\"\"\n        self.errors = []\n        for path_type, path_str in self.required_paths.items():\n            path = pathlib.Path(path_str)\n            if path_type == \"file\":\n                if not path.exists():\n                    self.errors.append(f\"Required file not found: {path_str}\")\n                elif not path.is_file():\n                    self.errors.append(f\"Path is not a file: {path_str}\")\n            elif path_type == \"directory\":\n                if not path.exists():\n                    try:\n                        path.mkdir(parents=True, exist_ok=True)\n                    except Exception as e:\n                        self.errors.append(f\"Cannot create directory {path_str}: {e}\")\n                elif not path.is_dir():\n                    self.errors.append(f\"Path is not a directory: {path_str}\")\n        return len(self.errors) == 0\n    \n    def get_errors(self) -> List[str]:\n        return self.errors\n\n# =============================================================================\n# CONFIGURATION MANAGER\n# =============================================================================\n\nclass ConfigurationManager:\n    \"\"\"Manages application configuration\"\"\"\n    \n    def __init__(self, config: ApplicationConfig):\n        self.config = config\n        self.logger = logging.getLogger(f\"{config.name}.ConfigurationManager\")\n    \n    def load(self) -> ApplicationConfig:\n        \"\"\"Load configuration from file\"\"\"\n        config_path = pathlib.Path(self.config.config_file)\n        if config_path.exists():\n            try:\n                with open(config_path, 'r') as f:\n                    data = json.load(f)\n                    # Update config with loaded data\n                    for key, value in data.items():\n                        if hasattr(self.config, key):\n                            setattr(self.config, key, value)\n                self.logger.info(f\"Configuration loaded from {config_path}\")\n            except Exception as e:\n                self.logger.warning(f\"Failed to load configuration: {e}\")\n        return self.config\n    \n    def save(self) -> None:\n        \"\"\"Save configuration to file\"\"\"\n        config_path = pathlib.Path(self.config.config_file)\n        try:\n            config_path.parent.mkdir(parents=True, exist_ok=True)\n            with open(config_path, 'w') as f:\n                json.dump(asdict(self.config), f, indent=2, default=str)\n            self.logger.info(f\"Configuration saved to {config_path}\")\n        except Exception as e:\n            self.logger.error(f\"Failed to save configuration: {e}\")\n\n# =============================================================================\n# METRICS AND MONITORING\n# =============================================================================\n\n@dataclass\nclass Metrics:\n    \"\"\"Application metrics\"\"\"\n    start_time: datetime = field(default_factory=datetime.now)\n    operations_completed: int = 0\n    operations_failed: int = 0\n    total_execution_time: float = 0.0\n    \n    def record_operation(self, success: bool, duration: float):\n        \"\"\"Record an operation\"\"\"\n        if success:\n            self.operations_completed += 1\n        else:\n            self.operations_failed += 1\n        self.total_execution_time += duration\n    \n    def get_summary(self) -> Dict[str, Any]:\n        \"\"\"Get metrics summary\"\"\"\n        total_ops = self.operations_completed + self.operations_failed\n        success_rate = (self.operations_completed / total_ops * 100) if total_ops > 0 else 0\n        avg_time = self.total_execution_time / total_ops if total_ops > 0 else 0\n        \n        return {\n            \"total_operations\": total_ops,\n            \"successful_operations\": self.operations_completed,\n            \"failed_operations\": self.operations_failed,\n            \"success_rate_percent\": round(success_rate, 2),\n            \"average_execution_time\": round(avg_time, 3),\n            \"total_runtime\": str(datetime.now() - self.start_time)\n        }\n\n# =============================================================================\n# CORE COMPONENTS\n# =============================================================================\n\n{{coreComponents}}\n\n# =============================================================================\n# MAIN APPLICATION CLASS\n# =============================================================================\n\nclass Application:\n    \"\"\"Main application class\"\"\"\n    \n    def __init__(self, config: ApplicationConfig):\n        self.config = config\n        self.logger = Logger(config)\n        self.log = self.logger.get_logger(\"Application\")\n        self.config_manager = ConfigurationManager(config)\n        self.metrics = Metrics()\n        self.validators = []\n        self._shutdown_event = threading.Event()\n        \n        # Setup signal handlers\n        signal.signal(signal.SIGINT, self._signal_handler)\n        signal.signal(signal.SIGTERM, self._signal_handler)\n    \n    def _signal_handler(self, signum, frame):\n        \"\"\"Handle shutdown signals\"\"\"\n        self.log.info(f\"Received signal {signum}, initiating shutdown...\")\n        self._shutdown_event.set()\n    \n    def initialize(self):\n        \"\"\"Initialize the application\"\"\"\n        self.log.info(f\"Initializing {self.config.name} v{self.config.version}\")\n        \n        # Load configuration\n        self.config = self.config_manager.load()\n        \n        # Setup validators\n        self._setup_validators()\n        \n        # Validate requirements\n        if not self._validate_requirements():\n            raise ConfigurationError(\"Validation failed\")\n        \n        self.log.info(\"Application initialized successfully\")\n    \n    def _setup_validators(self):\n        \"\"\"Setup validation components\"\"\"\n        self.validators = [\n            DependencyValidator({{dependencies}}),\n            FileSystemValidator({\n                \"directory\": self.config.data_dir,\n                \"directory\": self.config.output_dir,\n                \"directory\": self.config.temp_dir\n            })\n        ]\n    \n    def _validate_requirements(self) -> bool:\n        \"\"\"Validate all requirements\"\"\"\n        all_valid = True\n        for validator in self.validators:\n            if not validator.validate():\n                for error in validator.get_errors():\n                    self.log.error(error)\n                all_valid = False\n        return all_valid\n    \n    async def run_async(self):\n        \"\"\"Run the application asynchronously\"\"\"\n        try:\n            {{asyncMainLogic}}\n        except Exception as e:\n            self.log.error(f\"Async execution failed: {e}\", exc_info=True)\n            raise\n    \n    def run_sync(self):\n        \"\"\"Run the application synchronously\"\"\"\n        try:\n            {{syncMainLogic}}\n        except Exception as e:\n            self.log.error(f\"Sync execution failed: {e}\", exc_info=True)\n            raise\n    \n    def run(self):\n        \"\"\"Main execution method\"\"\"\n        start_time = datetime.now()\n        \n        try:\n            self.initialize()\n            \n            if self.config.enable_async:\n                asyncio.run(self.run_async())\n            else:\n                self.run_sync()\n            \n            # Save final configuration\n            self.config_manager.save()\n            \n            # Show metrics\n            if self.config.enable_metrics:\n                summary = self.metrics.get_summary()\n                self.log.info(\"Execution Summary:\")\n                for key, value in summary.items():\n                    self.log.info(f\"  {key}: {value}\")\n            \n            execution_time = datetime.now() - start_time\n            self.log.info(f\"Application completed successfully in {execution_time}\")\n            \n        except KeyboardInterrupt:\n            self.log.info(\"Application interrupted by user\")\n        except Exception as e:\n            self.log.error(f\"Application failed: {e}\", exc_info=True)\n            sys.exit(1)\n\n# =============================================================================\n# COMMAND LINE INTERFACE\n# =============================================================================\n\ndef create_argument_parser() -> argparse.ArgumentParser:\n    \"\"\"Create command line argument parser\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"{{description}}\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nAlsania Protocol v1.0 - Built by Sigma, Powered by Echo\n        \"\"\"\n    )\n    \n    parser.add_argument(\n        '--config', '-c',\n        type=str,\n        help='Configuration file path'\n    )\n    \n    parser.add_argument(\n        '--verbose', '-v',\n        action='store_true',\n        help='Enable verbose logging'\n    )\n    \n    parser.add_argument(\n        '--debug',\n        action='store_true',\n        help='Enable debug mode'\n    )\n    \n    parser.add_argument(\n        '--dry-run',\n        action='store_true',\n        help='Show what would be done without executing'\n    )\n    \n    parser.add_argument(\n        '--version',\n        action='version',\n        version=f\"{{scriptName}} {{version}}\"\n    )\n    \n    return parser\n\ndef main():\n    \"\"\"Application entry point\"\"\"\n    parser = create_argument_parser()\n    args = parser.parse_args()\n    \n    # Create initial config\n    config = ApplicationConfig()\n    \n    # Override with command line arguments\n    if args.config:\n        config.config_file = args.config\n    if args.verbose:\n        config.log_level = \"DEBUG\"\n    if args.debug:\n        config.debug = True\n    if args.dry_run:\n        config.dry_run = True\n    \n    # Create and run application\n    app = Application(config)\n    app.run()\n\nif __name__ == \"__main__\":\n    main()",
    "variables": [
        {
            "name": "description",
            "type": "string",
            "required": true,
            "description": "Application description"
        },
        {
            "name": "scriptName",
            "type": "string",
            "required": true,
            "description": "Application name"
        },
        {
            "name": "version",
            "type": "string",
            "required": false,
            "description": "Application version"
        },
        {
            "name": "dependencies",
            "type": "array",
            "required": false,
            "description": "Required Python modules"
        },
        {
            "name": "coreComponents",
            "type": "string",
            "required": true,
            "description": "Core application components and classes"
        },
        {
            "name": "asyncMainLogic",
            "type": "string",
            "required": false,
            "description": "Asynchronous main execution logic"
        },
        {
            "name": "syncMainLogic",
            "type": "string",
            "required": true,
            "description": "Synchronous main execution logic"
        }
    ],
    "requirements": [
        "python3"
    ],
    "alsaniaCompliant": true
}